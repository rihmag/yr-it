"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFile = void 0;
var tslib_1 = require("tslib");
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var file_1 = require("./file");
var utils_1 = require("./../../utils");
var filestack_error_1 = require("./../../../filestack_error");
var file_tools_1 = require("./file_tools");
/**
 * Check if file is buffer
 *
 * @node
 * @param input
 */
var isFileBuffer = function (input) { return Buffer.isBuffer(input); };
/**
 * Check if input is a valid file path
 *
 * @node
 * @param input
 */
var isFilePath = function (input) { return require('fs').existsSync(input); };
/**
 * Check if file is base64 string
 *
 * @param input
 */
var isFileBase = function (input) {
    if (typeof input !== 'string') {
        return false;
    }
    if (input.indexOf('base64') > -1 && file_tools_1.base64Regexp.test(input)) {
        input = input.match(file_tools_1.base64Regexp).pop();
    }
    if (Buffer.from(input, 'base64').toString('base64') === input) {
        return true;
    }
    return false;
};
/**
 * Accepts Buffer or filepath or base64 string
 *
 * @node
 * @param {*} inputFile
 * @returns {Promise<File>}
 */
var getFile = function (input, sanitizeOptions, mimetype) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var filename, path_1, matches, mime_1;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if ((0, file_tools_1.isFileNamed)(input)) {
                    filename = input.name;
                    input = input.file;
                }
                if (isFilePath(input)) {
                    path_1 = input;
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            require('fs').readFile(path_1, function (err, buffer) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
                                var mime;
                                return tslib_1.__generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (err) {
                                                return [2 /*return*/, reject(err)];
                                            }
                                            if (!filename) {
                                                filename = require && require('path').basename(path_1);
                                            }
                                            return [4 /*yield*/, (0, utils_1.getMimetype)(buffer, filename)];
                                        case 1:
                                            mime = _a.sent();
                                            return [2 /*return*/, resolve(new file_1.File({
                                                    name: filename,
                                                    size: buffer.byteLength,
                                                    type: mimetype || mime,
                                                    slice: function (start, end) { return Promise.resolve(buffer.slice(start, end)); },
                                                }, sanitizeOptions))];
                                    }
                                });
                            }); });
                        })];
                }
                if (isFileBase(input)) {
                    matches = input.match(file_tools_1.base64Regexp);
                    if (matches && matches.length === 2) {
                        input = Buffer.from(matches[2], 'base64');
                    }
                    else {
                        input = Buffer.from(input, 'base64');
                    }
                }
                if (!isFileBuffer(input)) return [3 /*break*/, 2];
                return [4 /*yield*/, (0, utils_1.getMimetype)(input, filename)];
            case 1:
                mime_1 = _a.sent();
                return [2 /*return*/, Promise.resolve(new file_1.File({
                        name: filename,
                        size: input.byteLength,
                        type: mimetype || mime_1,
                        // @ts-ignore
                        slice: function (start, end) { return Promise.resolve(input.slice(start, end)); },
                    }, sanitizeOptions))];
            case 2: return [2 /*return*/, Promise.reject(new filestack_error_1.FilestackError('Unsupported input file type'))];
        }
    });
}); };
exports.getFile = getFile;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLm5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILCtCQUF3QztBQUN4Qyx1Q0FBNkQ7QUFDN0QsOERBQTREO0FBQzVELDJDQUFvRTtBQUVwRTs7Ozs7R0FLRztBQUNILElBQU0sWUFBWSxHQUFHLFVBQUMsS0FBZ0IsSUFBc0IsT0FBQSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUF0QixDQUFzQixDQUFDO0FBRW5GOzs7OztHQUtHO0FBQ0gsSUFBTSxVQUFVLEdBQUcsVUFBQyxLQUFnQixJQUFzQixPQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQS9CLENBQStCLENBQUM7QUFFMUY7Ozs7R0FJRztBQUNILElBQU0sVUFBVSxHQUFHLFVBQUMsS0FBZ0I7SUFDbEMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSx5QkFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUM1RCxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyx5QkFBWSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDekM7SUFFRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsS0FBSyxLQUFLLEVBQUU7UUFDN0QsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ0ksSUFBTSxPQUFPLEdBQUcsVUFBTSxLQUFnQixFQUFFLGVBQWlDLEVBQUUsUUFBaUI7Ozs7O2dCQUdqRyxJQUFJLElBQUEsd0JBQVcsRUFBQyxLQUFLLENBQUMsRUFBRTtvQkFDdEIsUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7b0JBQ3RCLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDO2lCQUNwQjtnQkFFRCxJQUFJLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDakIsU0FBTyxLQUFLLENBQUM7b0JBQ2pCLHNCQUFPLElBQUksT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFFLE1BQU07NEJBQ2pDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBSSxFQUFFLFVBQU0sR0FBRyxFQUFFLE1BQU07Ozs7OzRDQUM1QyxJQUFJLEdBQUcsRUFBRTtnREFDUCxzQkFBTyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUM7NkNBQ3BCOzRDQUVELElBQUksQ0FBQyxRQUFRLEVBQUU7Z0RBQ2IsUUFBUSxHQUFHLE9BQU8sSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQUksQ0FBQyxDQUFDOzZDQUN0RDs0Q0FDVSxxQkFBTSxJQUFBLG1CQUFXLEVBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxFQUFBOzs0Q0FBMUMsSUFBSSxHQUFHLFNBQW1DOzRDQUM5QyxzQkFBTyxPQUFPLENBQ1osSUFBSSxXQUFNLENBQ1I7b0RBQ0UsSUFBSSxFQUFFLFFBQVE7b0RBQ2QsSUFBSSxFQUFFLE1BQU0sQ0FBQyxVQUFVO29EQUN2QixJQUFJLEVBQUUsUUFBUSxJQUFJLElBQUk7b0RBQ3RCLEtBQUssRUFBRSxVQUFDLEtBQUssRUFBRSxHQUFHLElBQUssT0FBQSxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQXpDLENBQXlDO2lEQUNqRSxFQUNELGVBQWUsQ0FDaEIsQ0FDRixFQUFDOzs7aUNBQ0gsQ0FBQyxDQUFDO3dCQUNMLENBQUMsQ0FBQyxFQUFDO2lCQUNKO2dCQUVELElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO29CQUNmLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLHlCQUFZLENBQUMsQ0FBQztvQkFDMUMsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7d0JBQ25DLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQztxQkFDM0M7eUJBQU07d0JBQ0wsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO3FCQUN0QztpQkFDRjtxQkFFRyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQW5CLHdCQUFtQjtnQkFDVixxQkFBTSxJQUFBLG1CQUFXLEVBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxFQUFBOztnQkFBekMsU0FBTyxTQUFrQztnQkFDN0Msc0JBQU8sT0FBTyxDQUFDLE9BQU8sQ0FDcEIsSUFBSSxXQUFNLENBQ1I7d0JBQ0UsSUFBSSxFQUFFLFFBQVE7d0JBQ2QsSUFBSSxFQUFFLEtBQUssQ0FBQyxVQUFVO3dCQUN0QixJQUFJLEVBQUUsUUFBUSxJQUFJLE1BQUk7d0JBQ3RCLGFBQWE7d0JBQ2IsS0FBSyxFQUFFLFVBQUMsS0FBSyxFQUFFLEdBQUcsSUFBSyxPQUFBLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBeEMsQ0FBd0M7cUJBQ2hFLEVBQ0QsZUFBZSxDQUNoQixDQUNGLEVBQUM7b0JBR0osc0JBQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLGdDQUFjLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxFQUFDOzs7S0FDMUUsQ0FBQztBQTdEVyxRQUFBLE9BQU8sV0E2RGxCIiwiZmlsZSI6ImxpYi9hcGkvdXBsb2FkL2ZpbGVfdG9vbHMubm9kZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTkgYnkgRmlsZXN0YWNrLlxuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBGaWxlIGFzIEZzRmlsZSB9IGZyb20gJy4vZmlsZSc7XG5pbXBvcnQgeyBTYW5pdGl6ZU9wdGlvbnMsIGdldE1pbWV0eXBlIH0gZnJvbSAnLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgeyBGaWxlc3RhY2tFcnJvciB9IGZyb20gJy4vLi4vLi4vLi4vZmlsZXN0YWNrX2Vycm9yJztcbmltcG9ydCB7IElucHV0RmlsZSwgYmFzZTY0UmVnZXhwLCBpc0ZpbGVOYW1lZCB9IGZyb20gJy4vZmlsZV90b29scyc7XG5cbi8qKlxuICogQ2hlY2sgaWYgZmlsZSBpcyBidWZmZXJcbiAqXG4gKiBAbm9kZVxuICogQHBhcmFtIGlucHV0XG4gKi9cbmNvbnN0IGlzRmlsZUJ1ZmZlciA9IChpbnB1dDogSW5wdXRGaWxlKTogaW5wdXQgaXMgQnVmZmVyID0+IEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgaW5wdXQgaXMgYSB2YWxpZCBmaWxlIHBhdGhcbiAqXG4gKiBAbm9kZVxuICogQHBhcmFtIGlucHV0XG4gKi9cbmNvbnN0IGlzRmlsZVBhdGggPSAoaW5wdXQ6IElucHV0RmlsZSk6IGlucHV0IGlzIHN0cmluZyA9PiByZXF1aXJlKCdmcycpLmV4aXN0c1N5bmMoaW5wdXQpO1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgaXMgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSBpbnB1dFxuICovXG5jb25zdCBpc0ZpbGVCYXNlID0gKGlucHV0OiBJbnB1dEZpbGUpOiBpbnB1dCBpcyBzdHJpbmcgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpbnB1dC5pbmRleE9mKCdiYXNlNjQnKSA+IC0xICYmIGJhc2U2NFJlZ2V4cC50ZXN0KGlucHV0KSkge1xuICAgIGlucHV0ID0gaW5wdXQubWF0Y2goYmFzZTY0UmVnZXhwKS5wb3AoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiYXNlNjQnKSA9PT0gaW5wdXQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQWNjZXB0cyBCdWZmZXIgb3IgZmlsZXBhdGggb3IgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBub2RlXG4gKiBAcGFyYW0geyp9IGlucHV0RmlsZVxuICogQHJldHVybnMge1Byb21pc2U8RmlsZT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGaWxlID0gYXN5bmMoaW5wdXQ6IElucHV0RmlsZSwgc2FuaXRpemVPcHRpb25zPzogU2FuaXRpemVPcHRpb25zLCBtaW1ldHlwZT86IHN0cmluZyk6IFByb21pc2U8RnNGaWxlPiA9PiB7XG4gIGxldCBmaWxlbmFtZTtcblxuICBpZiAoaXNGaWxlTmFtZWQoaW5wdXQpKSB7XG4gICAgZmlsZW5hbWUgPSBpbnB1dC5uYW1lO1xuICAgIGlucHV0ID0gaW5wdXQuZmlsZTtcbiAgfVxuXG4gIGlmIChpc0ZpbGVQYXRoKGlucHV0KSkge1xuICAgIGxldCBwYXRoID0gaW5wdXQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGUocGF0aCwgYXN5bmMoZXJyLCBidWZmZXIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgICAgICBmaWxlbmFtZSA9IHJlcXVpcmUgJiYgcmVxdWlyZSgncGF0aCcpLmJhc2VuYW1lKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtaW1lID0gYXdhaXQgZ2V0TWltZXR5cGUoYnVmZmVyLCBmaWxlbmFtZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKFxuICAgICAgICAgIG5ldyBGc0ZpbGUoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICBzaXplOiBidWZmZXIuYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgICAgdHlwZTogbWltZXR5cGUgfHwgbWltZSxcbiAgICAgICAgICAgICAgc2xpY2U6IChzdGFydCwgZW5kKSA9PiBQcm9taXNlLnJlc29sdmUoYnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzYW5pdGl6ZU9wdGlvbnNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0ZpbGVCYXNlKGlucHV0KSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBpbnB1dC5tYXRjaChiYXNlNjRSZWdleHApO1xuICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpbnB1dCA9IEJ1ZmZlci5mcm9tKG1hdGNoZXNbMl0sICdiYXNlNjQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShpbnB1dCwgJ2Jhc2U2NCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0ZpbGVCdWZmZXIoaW5wdXQpKSB7XG4gICAgbGV0IG1pbWUgPSBhd2FpdCBnZXRNaW1ldHlwZShpbnB1dCwgZmlsZW5hbWUpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICBuZXcgRnNGaWxlKFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgc2l6ZTogaW5wdXQuYnl0ZUxlbmd0aCxcbiAgICAgICAgICB0eXBlOiBtaW1ldHlwZSB8fCBtaW1lLFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBzbGljZTogKHN0YXJ0LCBlbmQpID0+IFByb21pc2UucmVzb2x2ZShpbnB1dC5zbGljZShzdGFydCwgZW5kKSksXG4gICAgICAgIH0sXG4gICAgICAgIHNhbml0aXplT3B0aW9uc1xuICAgICAgKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEZpbGVzdGFja0Vycm9yKCdVbnN1cHBvcnRlZCBpbnB1dCBmaWxlIHR5cGUnKSk7XG59O1xuIl19
