import { __awaiter, __generator } from "tslib";
/*
 * Copyright (c) 2019 by Filestack.
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { File as FsFile } from './file';
import { getMimetype } from './../../utils';
import { FilestackError } from './../../../filestack_error';
import { base64Regexp, isFileNamed } from './file_tools';
/**
 * Check if file is buffer
 *
 * @node
 * @param input
 */
var isFileBuffer = function (input) { return Buffer.isBuffer(input); };
/**
 * Check if input is a valid file path
 *
 * @node
 * @param input
 */
var isFilePath = function (input) { return require('fs').existsSync(input); };
/**
 * Check if file is base64 string
 *
 * @param input
 */
var isFileBase = function (input) {
    if (typeof input !== 'string') {
        return false;
    }
    if (input.indexOf('base64') > -1 && base64Regexp.test(input)) {
        input = input.match(base64Regexp).pop();
    }
    if (Buffer.from(input, 'base64').toString('base64') === input) {
        return true;
    }
    return false;
};
/**
 * Accepts Buffer or filepath or base64 string
 *
 * @node
 * @param {*} inputFile
 * @returns {Promise<File>}
 */
export var getFile = function (input, sanitizeOptions, mimetype) { return __awaiter(void 0, void 0, void 0, function () {
    var filename, path_1, matches, mime_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (isFileNamed(input)) {
                    filename = input.name;
                    input = input.file;
                }
                if (isFilePath(input)) {
                    path_1 = input;
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            require('fs').readFile(path_1, function (err, buffer) { return __awaiter(void 0, void 0, void 0, function () {
                                var mime;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            if (err) {
                                                return [2 /*return*/, reject(err)];
                                            }
                                            if (!filename) {
                                                filename = require && require('path').basename(path_1);
                                            }
                                            return [4 /*yield*/, getMimetype(buffer, filename)];
                                        case 1:
                                            mime = _a.sent();
                                            return [2 /*return*/, resolve(new FsFile({
                                                    name: filename,
                                                    size: buffer.byteLength,
                                                    type: mimetype || mime,
                                                    slice: function (start, end) { return Promise.resolve(buffer.slice(start, end)); },
                                                }, sanitizeOptions))];
                                    }
                                });
                            }); });
                        })];
                }
                if (isFileBase(input)) {
                    matches = input.match(base64Regexp);
                    if (matches && matches.length === 2) {
                        input = Buffer.from(matches[2], 'base64');
                    }
                    else {
                        input = Buffer.from(input, 'base64');
                    }
                }
                if (!isFileBuffer(input)) return [3 /*break*/, 2];
                return [4 /*yield*/, getMimetype(input, filename)];
            case 1:
                mime_1 = _a.sent();
                return [2 /*return*/, Promise.resolve(new FsFile({
                        name: filename,
                        size: input.byteLength,
                        type: mimetype || mime_1,
                        // @ts-ignore
                        slice: function (start, end) { return Promise.resolve(input.slice(start, end)); },
                    }, sanitizeOptions))];
            case 2: return [2 /*return*/, Promise.reject(new FilestackError('Unsupported input file type'))];
        }
    });
}); };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLm5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBRSxJQUFJLElBQUksTUFBTSxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ3hDLE9BQU8sRUFBbUIsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUM1RCxPQUFPLEVBQWEsWUFBWSxFQUFFLFdBQVcsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUVwRTs7Ozs7R0FLRztBQUNILElBQU0sWUFBWSxHQUFHLFVBQUMsS0FBZ0IsSUFBc0IsT0FBQSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUF0QixDQUFzQixDQUFDO0FBRW5GOzs7OztHQUtHO0FBQ0gsSUFBTSxVQUFVLEdBQUcsVUFBQyxLQUFnQixJQUFzQixPQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQS9CLENBQStCLENBQUM7QUFFMUY7Ozs7R0FJRztBQUNILElBQU0sVUFBVSxHQUFHLFVBQUMsS0FBZ0I7SUFDbEMsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQzVELEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3pDO0lBRUQsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQzdELE9B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bGUiOiJsaWIvYXBpL3VwbG9hZC9maWxlX3Rvb2xzLm5vZGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IGJ5IEZpbGVzdGFjay5cbiAqIFNvbWUgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgRmlsZSBhcyBGc0ZpbGUgfSBmcm9tICcuL2ZpbGUnO1xuaW1wb3J0IHsgU2FuaXRpemVPcHRpb25zLCBnZXRNaW1ldHlwZSB9IGZyb20gJy4vLi4vLi4vdXRpbHMnO1xuaW1wb3J0IHsgRmlsZXN0YWNrRXJyb3IgfSBmcm9tICcuLy4uLy4uLy4uL2ZpbGVzdGFja19lcnJvcic7XG5pbXBvcnQgeyBJbnB1dEZpbGUsIGJhc2U2NFJlZ2V4cCwgaXNGaWxlTmFtZWQgfSBmcm9tICcuL2ZpbGVfdG9vbHMnO1xuXG4vKipcbiAqIENoZWNrIGlmIGZpbGUgaXMgYnVmZmVyXG4gKlxuICogQG5vZGVcbiAqIEBwYXJhbSBpbnB1dFxuICovXG5jb25zdCBpc0ZpbGVCdWZmZXIgPSAoaW5wdXQ6IElucHV0RmlsZSk6IGlucHV0IGlzIEJ1ZmZlciA9PiBCdWZmZXIuaXNCdWZmZXIoaW5wdXQpO1xuXG4vKipcbiAqIENoZWNrIGlmIGlucHV0IGlzIGEgdmFsaWQgZmlsZSBwYXRoXG4gKlxuICogQG5vZGVcbiAqIEBwYXJhbSBpbnB1dFxuICovXG5jb25zdCBpc0ZpbGVQYXRoID0gKGlucHV0OiBJbnB1dEZpbGUpOiBpbnB1dCBpcyBzdHJpbmcgPT4gcmVxdWlyZSgnZnMnKS5leGlzdHNTeW5jKGlucHV0KTtcblxuLyoqXG4gKiBDaGVjayBpZiBmaWxlIGlzIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gaW5wdXRcbiAqL1xuY29uc3QgaXNGaWxlQmFzZSA9IChpbnB1dDogSW5wdXRGaWxlKTogaW5wdXQgaXMgc3RyaW5nID0+IHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaW5wdXQuaW5kZXhPZignYmFzZTY0JykgPiAtMSAmJiBiYXNlNjRSZWdleHAudGVzdChpbnB1dCkpIHtcbiAgICBpbnB1dCA9IGlucHV0Lm1hdGNoKGJhc2U2NFJlZ2V4cCkucG9wKCk7XG4gIH1cblxuICBpZiAoQnVmZmVyLmZyb20oaW5wdXQsICdiYXNlNjQnKS50b1N0cmluZygnYmFzZTY0JykgPT09IGlucHV0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgQnVmZmVyIG9yIGZpbGVwYXRoIG9yIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAbm9kZVxuICogQHBhcmFtIHsqfSBpbnB1dEZpbGVcbiAqIEByZXR1cm5zIHtQcm9taXNlPEZpbGU+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0RmlsZSA9IGFzeW5jKGlucHV0OiBJbnB1dEZpbGUsIHNhbml0aXplT3B0aW9ucz86IFNhbml0aXplT3B0aW9ucywgbWltZXR5cGU/OiBzdHJpbmcpOiBQcm9taXNlPEZzRmlsZT4gPT4ge1xuICBsZXQgZmlsZW5hbWU7XG5cbiAgaWYgKGlzRmlsZU5hbWVkKGlucHV0KSkge1xuICAgIGZpbGVuYW1lID0gaW5wdXQubmFtZTtcbiAgICBpbnB1dCA9IGlucHV0LmZpbGU7XG4gIH1cblxuICBpZiAoaXNGaWxlUGF0aChpbnB1dCkpIHtcbiAgICBsZXQgcGF0aCA9IGlucHV0O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICByZXF1aXJlKCdmcycpLnJlYWRGaWxlKHBhdGgsIGFzeW5jKGVyciwgYnVmZmVyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICAgICAgZmlsZW5hbWUgPSByZXF1aXJlICYmIHJlcXVpcmUoJ3BhdGgnKS5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWltZSA9IGF3YWl0IGdldE1pbWV0eXBlKGJ1ZmZlciwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShcbiAgICAgICAgICBuZXcgRnNGaWxlKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgc2l6ZTogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgIHR5cGU6IG1pbWV0eXBlIHx8IG1pbWUsXG4gICAgICAgICAgICAgIHNsaWNlOiAoc3RhcnQsIGVuZCkgPT4gUHJvbWlzZS5yZXNvbHZlKGJ1ZmZlci5zbGljZShzdGFydCwgZW5kKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2FuaXRpemVPcHRpb25zXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNGaWxlQmFzZShpbnB1dCkpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gaW5wdXQubWF0Y2goYmFzZTY0UmVnZXhwKTtcbiAgICBpZiAobWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShtYXRjaGVzWzJdLCAnYmFzZTY0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20oaW5wdXQsICdiYXNlNjQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNGaWxlQnVmZmVyKGlucHV0KSkge1xuICAgIGxldCBtaW1lID0gYXdhaXQgZ2V0TWltZXR5cGUoaW5wdXQsIGZpbGVuYW1lKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgbmV3IEZzRmlsZShcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgIHNpemU6IGlucHV0LmJ5dGVMZW5ndGgsXG4gICAgICAgICAgdHlwZTogbWltZXR5cGUgfHwgbWltZSxcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc2xpY2U6IChzdGFydCwgZW5kKSA9PiBQcm9taXNlLnJlc29sdmUoaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkpLFxuICAgICAgICB9LFxuICAgICAgICBzYW5pdGl6ZU9wdGlvbnNcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBGaWxlc3RhY2tFcnJvcignVW5zdXBwb3J0ZWQgaW5wdXQgZmlsZSB0eXBlJykpO1xufTtcbiJdfQ==
